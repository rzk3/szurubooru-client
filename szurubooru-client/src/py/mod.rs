use crate::models::PagedSearchResult;
use pyo3::prelude::*;
use pyo3::types::PyList;

// rustfmt likes to break the Python docstrings
#[rustfmt::skip]
pub mod asynchronous;
#[rustfmt::skip]
pub mod synchronous;

#[derive(Debug)]
#[pyclass(name = "PagedResult", get_all, module = "szurubooru_client")]
/// A paged result generated by most of the ``list`` methods of the Szurubooru clients
pub struct PyPagedSearchResult {
    /// The query string that was used to generate these results
    pub query: String,
    /// The offset for the request, how many resource to skip before returning the results
    pub offset: u32,
    /// The maximum number of results to return
    pub limit: u32,
    /// The total number of results generated by the query
    pub total: u32,
    /// The results themselves
    pub results: Py<PyList>,
}

#[cfg_attr(all(feature = "python"), pymethods)]
impl PyPagedSearchResult {
    fn __repr__(&self) -> String {
        format!("{:?}", self)
    }

    /*fn __len__(&self) -> PyResult<usize> {
        Python::with_gil(|py| {
            Ok(self.results.bind_borrowed(py).len())
        })
    }*/
}

impl<T: IntoPy<PyObject>> From<PagedSearchResult<T>> for PyPagedSearchResult {
    fn from(value: PagedSearchResult<T>) -> Self {
        Python::with_gil(|py| {
            let list =
                PyList::new_bound(py, value.results.into_iter().map(|v| v.into_py(py))).unbind();
            PyPagedSearchResult {
                query: value.query,
                offset: value.offset,
                limit: value.limit,
                total: value.total,
                results: list,
            }
        })
    }
}
